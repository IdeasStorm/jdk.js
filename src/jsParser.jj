/**
 * JavaCC file
 */
 
options {
  JDK_VERSION = "1.5";
}
PARSER_BEGIN(compiler)

import java.io.FileInputStream;
import java.io.InputStreamReader;
import java.io.FileNotFoundException;

public class compiler {
  public static void main(String args[]) throws ParseException, FileNotFoundException  {
    compiler parser = new compiler(new InputStreamReader(new FileInputStream("src//code.txt")));
    parser.start();
    System.out.println("End Of Parser.");  	
  }
}
PARSER_END(compiler)

SKIP :
{
 	" "
|	"\r"
|	"\t"
|	"\n"
|	<"//" (~["\n"])* "\n">		//skip single-line comments
|	<"/*"> : COMMENT			//skip multi-line comments
}



TOKEN : /* LOGIC OPERATORS */
{
 	< AND: "&&">
|	< OR: "||">
|	< NOT: "!">
}

TOKEN : /* SIGN COMPARE */
{
	< GT: ">" >
| 	< GTE: ">=" >
| 	< LT: "<" >
| 	< LTE: "<=" >
| 	< EQ: "==" >
}

TOKEN : /* PROTOTYE */
{
	< TYPE: "var" >
}

TOKEN : /* LOOPS */
{
	< FOR: "for" >
|	< WHILE: "while" >
|	< DO: "do" >
}

TOKEN : /* COMPARE */
{
	< IF: "if" >
|	< ELSE: "else" >
|	< TRUE: "true" >
|	< FALSE: "false" >
|	< SWITCH: "switch" >
|	< CASE: "case" >
|	< CONTINUE: "continue" >
|	< BREAK: "break" >
}

TOKEN : /* KEYWORDS */
{	
	< RETURN: "return" >
|	< FUNCTION: "function" >
|	< TRY: "try" >
|	< CATCH: "catch" >
|	< DELETE: "delete" >
|	< FINALLY: "finally" >
|	< IN: "in" >
|	< INSTANCEOF: "instanceof" >
|	< TYPEOF: "typeof" >
|	< NEW: "new" >
|	< THIS: "this" >
|	< THROW: "throw" >
| 	< VOID: "void" >
|	< WITH: "with" >
|	< NULL: "null" >
|	< UNDEFINED: "undefined" >
|	< SEMICOLON: ";" >
|   < _DEFAULT: "default" >
}


TOKEN : /* VARIABLE */
{
/*
	< IDENTIFIER:  ( <CHARACTER> )  (( <DIGIT> ) | <CHARACTER>)* >
|	< #CHARACTER: ["a"-"z", "A"-"Z","_","$"]>
|	< DIGIT: ["0" - "9"]>
*/

	< NUMBER: (["0" - "9"])+>
|	< DIGIT: ["0" - "9"]>
|	< #CHARACTER: ["a"-"z", "A"-"Z","_","$"]>
|	< IDENTIFIER:  ( <CHARACTER> )  (( <DIGIT> ) | <CHARACTER>)* >


}

<COMMENT> SKIP :
{ 
	<~[]>
|	<"*/"> : DEFAULT
}

//	BEGIN LITERALS
void Literal(): {}
{
	NullLiteral()
|	BooleanLiteral()
|	NumericLiteral()
|	StringLiteral()
// | RegularExpressionLiteral()

}
void NullLiteral(): {}
{
	<NULL>
}
void BooleanLiteral(): {}
{
	<TRUE>
|	<FALSE>
}

void NumericLiteral(): {}
{
	
	DecimalLiteral()
	
}

void DecimalLiteral(): {}
{
(	DecimalIntegerLiteral() 
	(	"." (DecimalDigits())? (ExponentPart())?
|	(ExponentPart())?	
	)
)
|	"." DecimalDigits() (ExponentPart())? 
}


void DecimalIntegerLiteral(): {}
{
//	"0"
//|
//	NonZeroDigit() (DecimalDigits())?
	<NUMBER>
}

void DecimalDigit(): {}
{
//	"0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
	<DIGIT>
}

void DecimalDigits(): {}
{
//	(DecimalDigit())+
		<NUMBER>
}

void NonZeroDigit(): {}
{
//	"1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
	<DIGIT>
}

void ExponentPart(): {}
{
	("e" | "E") SignedInteger()
}


void SignedInteger(): {}
{
	DecimalDigits()
| 	"+" DecimalDigits()
|	"-" DecimalDigits()
}

void StringLiteral(): {}
{

	"\"" (DoubleStringCharacters())? "\""
|	"\'" (SingleStringCharacters())? "\'"
}
void DoubleStringCharacters() : {}
{
	( DoubleStringCharacter() )+
}

void SingleStringCharacters() : {}
{
	(SingleStringCharacter())+
}

void DoubleStringCharacter() : {}
{
	SourceCharacter() // but not one of " or \ or LineTerminator
//|	"\\" EscapeSequence()
//|	LineContinuation()
	
}

void SingleStringCharacter() : {}
{
	SourceCharacter() // but not one of ' or \ or LineTerminator
//|	\ EscapeSequence
//|	LineContinuation
}


//TODO ALL Character !!
void SourceCharacter() : {}
{
	";"
}
//		END LITERALS


// BEGIN PRIMARY EXPRESSION
void PrimaryExpression() :{}
{
	"this"
|	<IDENTIFIER>
|	Literal()
|	ArrayLiteral()
|	ObjectLiteral()
|	"(" Expression() ")"
}

void ArrayLiteral(): {}
{
	"["
(	( (Elision())? "]" )
	|
	(	 	ElementList() 
			 ("]"
		| 	 "," (Elision())? "]")
	)
)
}

void ElementList(): {}
{
	(Elision())? AssignmentExpression() ( "," ElementList())*
}

void Elision(): {}
{
	(",")+
}

void ObjectLiteral(): {}
{
	"{" 
	(	"}"
		|
		(PropertyNameAndValueList() 
			( "}" | ","  "}" )
		)
	)
}

void PropertyNameAndValueList(): {}
{
	PropertyAssignment() (LOOKAHEAD(1)"," PropertyAssignment() )*
}

void PropertyAssignment(): {}
{
	PropertyName() ":" AssignmentExpression()
}

void PropertyName(): {}
{
	< IDENTIFIER>
|	StringLiteral()
|	NumericLiteral()
}

// 		LEFT HAND SIDE EXPRESSION
void LeftHandSideExpression() : {}
{
	MemberExpression() (Arguments())?
}

void MemberExpression(): {}
{
	PrimaryExpression()
|	FunctionExpression()
//|	MemberExpression() "[" Expression() "]"  // 		there is left-recursion
//|	MemberExpression() "." IdentifireName()	 //		there is left recursion
|	"new" MemberExpression() Arguments()
}

void NewExpression(): {}
{
	"new" MemberExpression()
}

void CallExpression(): {}
{
	MemberExpression() Arguments() (MemberExpression() Arguments() (Arguments() | "[" Expression() "]" | "." <IDENTIFIER> )*)?
}

void Arguments(): {}
{
	"(" (ArgumentList())? ")"
}

void ArgumentList(): {}
{
	AssignmentExpression() ("," AssignmentExpression() )*
}

void PostfixExpression(): {}
{
	LeftHandSideExpression() ("++" | "--")?
}

// Unary Expression
void UnaryExpression(): {}
{
	PostfixExpression()
|	"typeof" UnaryExpression()
|	"++" UnaryExpression()
|	"--" UnaryExpression()
|	"+" UnaryExpression()
|	"-" UnaryExpression()
|	"!" UnaryExpression()
}

//	Multiplicative Expression
void MultiplicativeExpression(): {}
{
	UnaryExpression() ("*" UnaryExpression() | "/" UnaryExpression() | "%" UnaryExpression() )*
}

// Additive Expression
void AdditiveExpression(): {}
{
	MultiplicativeExpression() ("+" MultiplicativeExpression() | "-" MultiplicativeExpression() )*
}

//Shift Expression
void ShiftExpression(): {}
{
	AdditiveExpression() (">>" AdditiveExpression() | "<<" AdditiveExpression() | ">>>" AdditiveExpression())*
}

//Relational Expression
void RelationalExpression(): {}
{
//	ShiftExpression() ("<" ShiftExpression() | ">" ShiftExpression() | "<=" ShiftExpression() | ">=" ShiftExpression() | <INSTANCEOF> ShiftExpression() | <IN> ShiftExpression()  )*
	ShiftExpression() (("<" | ">"  | "<=" | ">="  | <INSTANCEOF>  | <IN>) ShiftExpression()  )*
}

//Equality Expression
void EqualityExpression(): {}
{
	RelationalExpression()  ( ( "==" | "!=" | "===" | "!=="  ) RelationalExpression()  )*
}

//BINARY BITWISE OPERATORS
//BitwiseAND Expression
void BitwiseANDExpression(): {}
{
	EqualityExpression() ("&" EqualityExpression()  )*
}
//BitwiseXORExpression
void BitwiseXORExpression(): {}
{
	BitwiseANDExpression() ("^" BitwiseANDExpression() )*
}
//bitwiseORExpression
void BitwiseORExpression() : {}
{
	BitwiseXORExpression() ("|" BitwiseXORExpression())*
}

//BINARY LOGICAL OPERATORS
void LogicalANDExpression():{}
{
	BitwiseORExpression() (<AND> BitwiseORExpression())*
}

void LogicalORExpression(): {}
{
	LogicalANDExpression() ("||" LogicalANDExpression() )*
}

//Conditional Expression
void ConditionalExpression():{}
{
	LogicalORExpression() ("?" AssignmentExpression() ":" AssignmentExpression() )?

}

void AssignmentExpression(): {}
{

(LOOKAHEAD( LeftHandSideExpression() AssignmentOperator() )
 		LeftHandSideExpression() AssignmentOperator() )* ConditionalExpression()

	/*(LOOKAHEAD(ConditionalExpression())
	ConditionalExpression()
|
	( 	LeftHandSideExpression() 
		AssignmentOperator()  AssignmentExpression()
	)
)*/
}

void AssignmentOperator(): {}
{
	"*=" | "/=" | "%=" | "+=" | "-=" | "="
}

// Expression Finally !!

void Expression(): {}
{
	AssignmentExpression() ("," AssignmentExpression())*
}


//Statement
void Block() : {}
{
	"{" StatementList() "}"
}

void StatementList() : {}
{
	(Statement())*

}

VariableStatement VariableStatement() : 
{
	HashMap<String, ExpressionNode> values ;
}
{
	<TYPE> values = VariableDeclarationList() ";"
	{	VariableStatement VarSta = new VariableStatement(values) ;
		return 	VarSta ;}
}

HashMap<String, ExpressionNode> VariableDeclarationList() : 
{
	HashMap<String, ExpressionNode> values ;
	HashMap<String, ExpressionNode> value ;
}
{
	value = VariableDeclaration(){values.putAll(value);} (LOOKAHEAD(1) "," VariableDeclarationList())*
	{return values ;}	
}

HashMap<String, ExpressionNode> VariableDeclaration() : 
{
	HashMap<String, ExpressionNode> value ;
	String s ;
	ExpressionNode exp ;
}
{
	s = <IDENTIFIER> ( exp = Initialiser())?
	{
		value.put(s,exp);
		return value;
	}
}


void VariableDeclarationListNoIn() : {}
{
	VariableDeclarationNoIn() ( "," VariableDeclarationNoIn())* 
}

void VariableDeclarationNoIn() : {}
{
	<IDENTIFIER> (InitialiserNoIn())?
	
}

void Initialiser() : {}
{
	"=" AssignmentExpression()
	
}
void InitialiserNoIn() : {}
{
	"=" //AssignmentExpressionNoIn()
}


void EmptyStatement() : {}
{
	";"
}

void ExpressionStatement() : {}
{
	// TODO [lookahead != {{, function}] 
	Expression() ";"
}

void IfStatement() : {}
{
	<IF> "(" Expression() ")" Statement() (LOOKAHEAD(1) <ELSE> Statement())?
}

void IterationStatement() : {}
{
	DoWhileStatement()
|	WhileStatement()
|	ForStatement()
}

void DoWhileStatement() : {}
{
	<DO> Statement() <WHILE> "(" Expression() ")" ";"
}
void WhileStatement() : {}
{
	<WHILE> "(" Expression() ")" Statement()
}

void ForStatement() : {}
{
	<FOR> "(" 
	(
//		(ExpressionNoIn())? ";" (Expression())? ";" (Expression())? ")" Statement()
//		<TYPE> VariableDeclarationListNoIn() ";" (Expression())? ";" (Expression())? ")" Statement()
//	|	<TYPE> VariableDeclarationNoIn() "in" Expression() ")" Statement()
//	|
(LOOKAHEAD(LeftHandSideExpression() "in")
		LeftHandSideExpression() "in" Expression() ")" Statement()
	|	(Expression())? ";" (Expression())? ";" (Expression())? ")" Statement()

	)
)
}

void ContinueStatement() : {}
{
	<CONTINUE>
(	(";")
|
//	[no LineTerminator here] 
	(<IDENTIFIER> ";" )
)
}

void Statement() : {}
{
	Block()
|	VariableStatement()
|	EmptyStatement()
|	ExpressionStatement()
|	IfStatement()
|	IterationStatement()
/*|	ContinueStatement()
|	BreakStatement()
|	ReturnStatement()
|	WithStatment
*/

}

// FunctionDeclaration
void FunctionDeclaration() : {}
{
	<FUNCTION> <IDENTIFIER> "(" ( FormalParameterList() )? ")" "{" FunctionBody() "}"
}

void FunctionExpression() : {}
{
	<FUNCTION> (<IDENTIFIER>)? "(" (FormalParameterList())? ")" "{" FunctionBody() "}"
}

void FormalParameterList() : {} 
{
	<IDENTIFIER> ("," <IDENTIFIER>)* 
}

void FunctionBody() : {}
{
	(SourceElements())?
}

// Program
void Program() : {}
{
	(SourceElements())? // ?
}

void SourceElements() : {}
{
	(SourceElement())+
}

void SourceElement() : {}
{
	//TODO FIXED IT
( LOOKAHEAD (FunctionDeclaration())
	FunctionDeclaration() 
|	Statement()
)
}

void start() : {}
{
//	LeftHandSideExpression() "=" LeftHandSideExpression()
	ExpressionStatement()
	//Program() <EOF>
//	ArrayLiteral()
//	";"
//<NUMBER>
}
