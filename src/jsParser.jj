/**
 * JavaCC file
 */
 
options {
  JDK_VERSION = "1.5";
}
PARSER_BEGIN(compiler)

import java.io.FileInputStream;
import java.io.InputStreamReader;
import java.io.FileNotFoundException;
import parser.*;
import java.util.HashMap;

public class compiler {
  public static void main(String args[]) throws ParseException, FileNotFoundException  {
    compiler parser = new compiler(new InputStreamReader(new FileInputStream("src//code.txt")));
    parser.start();
    System.out.println("End Of Parser.");  	
  }
}
PARSER_END(compiler)

SKIP :
{
 	" "
|	"\r"
|	"\t"
|	"\n"
|	<"//" (~["\n"])* "\n">		//skip single-line comments
|	<"/*"> : COMMENT			//skip multi-line comments
}



TOKEN : /* LOGIC OPERATORS */
{
	< DOUBLEQUOTE: "\"">	: DOUBLE_STRING
|	< SINGLEQUOTE:"'">		: SINGLE_STRING
| 	< AND: "&&" | "and" >
|	< OR: "||" | "or" >
|	< NOT: "!" | "not" >
}

TOKEN : /* SIGN COMPARE */
{
	< GT: ">" >
| 	< GTE: ">=" >
| 	< LT: "<" >
| 	< LTE: "<=" >
| 	< EQ: "==" >
}

TOKEN : /* PROTOTYE */
{
	< TYPE: "var" >
}

TOKEN : /* LOOPS */
{
	< FOR: "for" >
|	< WHILE: "while" >
|	< DO: "do" >
}

TOKEN : /* COMPARE */
{
	< IF: "if" >
|	< ELSE: "else" >
|	< TRUE: "true" >
|	< FALSE: "false" >
|	< SWITCH: "switch" >
|	< CASE: "case" >
|	< CONTINUE: "continue" >
|	< BREAK: "break" >
}

TOKEN : /* KEYWORDS */
{	
	< RETURN: "return" >
|	< FUNCTION: "function" >
|	< TRY: "try" >
|	< CATCH: "catch" >
|	< DELETE: "delete" >
|	< FINALLY: "finally" >
|	< IN: "in" >
|	< INSTANCEOF: "instanceof" >
|	< TYPEOF: "typeof" >
|	< NEW: "new" >
|	< THIS: "this" >
|	< THROW: "throw" >
| 	< VOID: "void" >
|	< WITH: "with" >
|	< NULL: "null" >
|	< UNDEFINED: "undefined" >
|	< SEMICOLON: ";" >
|   < _DEFAULT: "default" >
}


TOKEN : /* VARIABLE */
{
/*
	< IDENTIFIER:  ( <CHARACTER> )  (( <DIGIT> ) | <CHARACTER>)* >
|	< #CHARACTER: ["a"-"z", "A"-"Z","_","$"]>
|	< DIGIT: ["0" - "9"]>
*/

	< NUMBER: (["0" - "9"])+ | ( (["0" - "9"])* ("." (["0" - "9"])+) )>
|	< DIGIT: ["0" - "9"]>
|	< #CHARACTER: ["a"-"z", "A"-"Z","_","$"]>
|	< IDENTIFIER:  ( <CHARACTER> )  (( <DIGIT> ) | <CHARACTER>)* >


}

<COMMENT> SKIP :
{ 
	<~[]>
|	<"*/"> : DEFAULT
}

<DOUBLE_STRING> TOKEN:
{
  <DOUBLEENDQUOTE:"\""> : DEFAULT
| <DOUBLECHAR:~["\"","\\"]>
}

<DOUBLE_STRING> MORE:
{
  "\\" : ESC_STATE
}

<SINGLE_STRING> TOKEN:
{
  <SINGLEENDQUOTE:"'"> : DEFAULT
| <SINGLECHAR:~[]>
}


<ESC_STATE> TOKEN:
{
  <CNTRL_ESC:["\"","\\","/","b","f","n","r","t"]> : DOUBLE_STRING
}
void doubleString_getChar(StringBuilder builder):
{
  Token t;
}
{
  ( t = <DOUBLECHAR> | t = <CNTRL_ESC> )
  {
    if (t.image.length() < 2)
    {
      // CHAR
      builder.append(t.image.charAt(0));
    }
    else if (t.image.length() < 6)
    {
      // ESC
      char c = t.image.charAt(1);
      switch (c)
      {
        case 'b': builder.append((char) 8); break;
        case 'f': builder.append((char) 12); break;
        case 'n': builder.append((char) 10); break;
        case 'r': builder.append((char) 13); break;
        case 't': builder.append((char) 9); break;
        default: builder.append(c);
      }
    }
  }
}
void singleString_getChar(StringBuilder builder):
{
  Token t;
}
{
  ( t = <SINGLECHAR>  )
  {
      builder.append(t.image);
  }
}


//	BEGIN LITERALS
LiteralNode Literal(): {
	LiteralNode literal;
}
{
(
	literal = NullLiteral()
|	literal = BooleanLiteral()
|	literal = NumericLiteral()
|	literal = StringLiteral()
// | RegularExpressionLiteral() TODO in future 

)

{return literal;}

}
LiteralNode NullLiteral(): {}
{
	<NULL>
	{
		return LiteralNode.createNullLiteral();
	}
}

LiteralNode BooleanLiteral(): 
{
	Token symbol;
}
{
	(
		symbol = <TRUE>
	|	symbol = <FALSE>
	)
	{
		return LiteralNode.createBooleanLiteral(symbol.image);
	}
}

LiteralNode NumericLiteral(): 
{
	LiteralNode num ;
}
{	
	num = DecimalLiteral()
	{
		//TODO Get the real Number Literal
		//return LiteralNode.createNumberLiteral("0.0");
		return num ;
	}	
}

LiteralNode DecimalLiteral(): 
{
	LiteralNode num ;
}
{
	(	num = DecimalIntegerLiteral() 
//TODO		(	"." (DecimalDigits())? (ExponentPart())?
//	|	(ExponentPart())?	
//		)
	)
//	|	("." DecimalDigits() (ExponentPart())?)
	{return num ;}
}


LiteralNode DecimalIntegerLiteral(): 
{
	Token num ;
}
{
//	"0" TODO 
//|
//	NonZeroDigit() (DecimalDigits())?
	num = <NUMBER>
	{ return LiteralNode.createNumberLiteral(num.image);}
}

void DecimalDigit(): {}
{
//	"0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
	<DIGIT>
}

LiteralNode DecimalDigits(): 
{
	Token num ; 
}
{
//	(DecimalDigit())+
		num = <NUMBER>
		{ return LiteralNode.createNumberLiteral(num.image);}
}

void NonZeroDigit(): {}
{
//	"1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
	<DIGIT>
}

void ExponentPart(): {}
{
	("e" | "E") SignedInteger()
}


void SignedInteger(): {}
{
		DecimalDigits()
	| 	"+" DecimalDigits()
	|	"-" DecimalDigits()
}

LiteralNode StringLiteral(): 
{
	String s="";
}
{
	(	<DOUBLEQUOTE> (s=DoubleStringCharacters())? <DOUBLEENDQUOTE>
	|	<SINGLEQUOTE> (s=SingleStringCharacters())? <SINGLEENDQUOTE>
	)
	{
		return LiteralNode.createStringLiteral(s);
	}
}

String DoubleStringCharacters() : {
 StringBuilder builder = new StringBuilder();
}
{
	( doubleString_getChar(builder) )+
	{
		return builder.toString();
	}
}

String SingleStringCharacters() : 
{
	 StringBuilder builder = new StringBuilder();
}
{
	( singleString_getChar(builder) )+
	{
		return builder.toString();
	}
}
//		END LITERALS


// BEGIN PRIMARY EXPRESSION
ExpressionNode PrimaryExpression() :{
	ExpressionNode exp = null;
	Token identifier;
	LiteralNode literal;
}
{
(
	"this" {
		exp = VariableNode.thisNode;
	}
|	identifier = <IDENTIFIER> {
		exp =  new VariableNode(identifier.image);
	}
|	literal = Literal() {
		exp = literal;
	}
|	ArrayLiteral() {
		exp = null;
		//TODO fill exp
	}
|	ObjectLiteral() {
		exp = null;
		//TODO fill exp
	}
|	"(" Expression() ")" {
		exp = null;
		//TODO fill exp
	}

)
	{
		return exp;
	}
}

void ArrayLiteral(): {}
{
	"["
(	( (Elision())? "]" )
	|
	(	 	ElementList() 
			 ("]"
		| 	 "," (Elision())? "]")
	)
)
}

void ElementList(): {}
{
	(Elision())? AssignmentExpression() ( "," ElementList())*
}

void Elision(): {}
{
	(",")+
}

void ObjectLiteral(): {}
{
	"{" 
	(	"}"
		|
		PropertyNameAndValueList()  (",")? "}"
	)
}

void PropertyNameAndValueList(): {}
{
	PropertyAssignment() (LOOKAHEAD(1)"," PropertyAssignment() )*
}

void PropertyAssignment(): {}
{
	PropertyName() ":" AssignmentExpression()
|	"get" PropertyName() "(" ")" "{" FunctionBody() "}" 
|	"set" PropertyName() "(" <IDENTIFIER> ")" "{" FunctionBody() "}" 
	
}

void PropertyName(): {}
{
		< IDENTIFIER>
	|	StringLiteral()
	|	NumericLiteral()
}

// 		LEFT HAND SIDE EXPRESSION
ExpressionNode LeftHandSideExpression() :
{
	ExpressionNode exp = null ;
}
{
	//MemberExpression() (Arguments())?
(LOOKAHEAD (CallExpression()) 
		CallExpression()
|		exp = NewExpression()
)
{return exp ;}
}

ExpressionNode MemberExpression(): 
{
	ExpressionNode exp = null ;
}
{
((
(	exp = PrimaryExpression()
|	FunctionExpression()
)
	( //TODO return ExpressionNode !!!
	("[" Expression() "]")  // there is solution for left-recursion
	|("." <IDENTIFIER>)	 // not uses IdentifierName()
	)*
)
|	"new" MemberExpression() Arguments()
) {return exp ;}
}

ExpressionNode NewExpression(): 
{
	ExpressionNode exp = null ;
}
{
(LOOKAHEAD (MemberExpression())
	exp = MemberExpression()
	//TODO return ExpressionNode !!!	
|	"new" MemberExpression()
)
{return exp ;}
}

void CallExpression(): {}
{ 
//	(MemberExpression() Arguments() (Arguments() | "[" Expression() "]" | "." <IDENTIFIER> )*)?
	MemberExpression() Arguments()
	(
		( Arguments() )
		|
		( "[" Expression() "]" )
		|
		( "." <IDENTIFIER> ) 
	)*
	
}

void Arguments(): {}
{
	"(" (ArgumentList())? ")"
}

void ArgumentList(): {}
{
	AssignmentExpression() ("," AssignmentExpression() )*
}

ExpressionNode PostfixExpression(): 
{
	ExpressionNode exp ;
	ExpressionNode left; 
}
{
(	
	left = LeftHandSideExpression() { exp = left ;}
	(
	 ( "++" { exp = new OperatorNode(OperatorNode.OperatorType.PostIncrement,left , null) ;} ) 
	|( "--" { exp = new OperatorNode(OperatorNode.OperatorType.PostDecrement,left ,null) ;} )
	)?
)
	{return exp ;}
}

// Unary Expression
ExpressionNode UnaryExpression(): 
{
	ExpressionNode exp ;
	ExpressionNode right ;
}
{
(
	( exp = PostfixExpression() )
//	|	"typeof" UnaryExpression()
	|	( "++" right = UnaryExpression() { exp = new OperatorNode(OperatorNode.OperatorType.PreIncrement,null , right) ;} )
	|	( "--" right = UnaryExpression() { exp = new OperatorNode(OperatorNode.OperatorType.PreDecrement,null , right) ;} )
	|	( "+" right = UnaryExpression() { exp = new OperatorNode(OperatorNode.OperatorType.Add,null , right) ;}  )
	|	( "-" right = UnaryExpression() { exp = new OperatorNode(OperatorNode.OperatorType.Subtract,null , right) ;}  )
	|	( <NOT> right = UnaryExpression() { exp = new OperatorNode(OperatorNode.OperatorType.Not,null , right) ;} )
)
	{return exp ;}
}

//	Multiplicative Expression
ExpressionNode MultiplicativeExpression(): 
{
	ExpressionNode exp,left,right =null; 
}
{
(
	( left = UnaryExpression() {exp = left ;}) 
	(
		( "*" right = UnaryExpression() { exp = new OperatorNode(OperatorNode.OperatorType.Multiply,left , right) ;  left = exp ; }) 
	|	(  "/" UnaryExpression() { exp = new OperatorNode(OperatorNode.OperatorType.Division,left , right) ;  left = exp ; } )
	|	( "%" UnaryExpression() { exp = new OperatorNode(OperatorNode.OperatorType.Mod,left , right) ;  left = exp ; } ) 
	)*
)
	{return exp ;}
}

// Additive Expression
ExpressionNode AdditiveExpression():
{
	ExpressionNode exp,left,right = null ; 
}
{
(
	( left =MultiplicativeExpression() {exp = left ; })  
	(
		( "+" MultiplicativeExpression() { exp = new OperatorNode(OperatorNode.OperatorType.Add, left , right) ;  left = exp ; }  ) 
	| 	( "-" MultiplicativeExpression() { exp = new OperatorNode(OperatorNode.OperatorType.Subtract ,left , right) ;  left = exp ; }  ) 
	)*
)
	{return exp ;}
}

//Shift Expression
ExpressionNode ShiftExpression(): 
{
	ExpressionNode exp = null ; 
}
{
(
	exp = AdditiveExpression() 
	(
	">>" AdditiveExpression() 
	| "<<" AdditiveExpression() 
	| ">>>" AdditiveExpression()
	)*
)
	{return exp ;}
}

//Relational Expression
ExpressionNode RelationalExpression(): 
{
	ExpressionNode exp,left,right = null ;
	OperatorNode.OperatorType op ; 
}
{
//	ShiftExpression() ("<" ShiftExpression() | ">" ShiftExpression() | "<=" ShiftExpression() | ">=" ShiftExpression() | <INSTANCEOF> ShiftExpression() | <IN> ShiftExpression()  )*
(
	( left = ShiftExpression() {exp = left ;}) 
	(
		(
			 "<" { op = OperatorNode.OperatorType.Less; }    
		|	 ">"  { op = OperatorNode.OperatorType.Greater; }
		|	 "<=" { op = OperatorNode.OperatorType.LessOrEqual; }
		|	 ">="  { op = OperatorNode.OperatorType.GreaterOrEqual; }
		|	 <INSTANCEOF>  { op = OperatorNode.OperatorType.INSTANCEOF; }
		|	 <IN> { op = OperatorNode.OperatorType.In; }
		)
		right = ShiftExpression() { exp = new OperatorNode(op, left , right) ;  left = exp ; }  
	)*
)
	{return exp ;}
}

//Equality Expression
ExpressionNode EqualityExpression(): 
{
	ExpressionNode exp,left,right ;
	OperatorNode.OperatorType op ;
}
{
(
	left = RelationalExpression() {exp = left;}  
	(
		 (
		  "=="  { op = OperatorNode.OperatorType.Equals; }
		  | "!="  { op = OperatorNode.OperatorType.NotEquals; }
//		  | "===" { op = OperatorNode.OperatorType.INSTANCEOF; }
//		  | "!=="  { op = OperatorNode.OperatorType.INSTANCEOF; }
		 )
		 right = RelationalExpression() { exp = new OperatorNode(op, left , right) ;  left = exp ; }
	)*
)
	{return exp ;}
}

//BINARY BITWISE OPERATORS
//BitwiseAND Expression
ExpressionNode BitwiseANDExpression(): 
{
	ExpressionNode exp,left,right ;
}
{
(
	left = EqualityExpression() {exp = left ;} 
	(
		"&" right = EqualityExpression() { exp = new OperatorNode(OperatorNode.OperatorType.BitWiseAnd, left , right) ;  left = exp ; }
	)*
)
	{return exp ; }
}
//BitwiseXORExpression
ExpressionNode BitwiseXORExpression(): 
{
	ExpressionNode exp,left,right ;
}
{
(
	left = BitwiseANDExpression() {exp = left ;} 
	(
		"^" right = BitwiseANDExpression() { exp = new OperatorNode(OperatorNode.OperatorType.BitWiseXor, left , right) ;  left = exp ; }
	)*
)
	{return exp ;}
}
//bitwiseORExpression
ExpressionNode BitwiseORExpression() : 
{
	ExpressionNode exp,left,right ;
}
{
(
	left = BitwiseXORExpression() {exp = left ;}
	(
		"|" right = BitwiseXORExpression() { exp = new OperatorNode(OperatorNode.OperatorType.BitWiseOr, left , right) ;  left = exp ; }
	)*
)
	{return exp ;}
}

//BINARY LOGICAL OPERATORS
ExpressionNode LogicalANDExpression():
{
	ExpressionNode exp,left,right;
}
{
(
	left = BitwiseORExpression() {exp =left;} 
	(
		<AND> right = BitwiseORExpression() { exp = new OperatorNode(OperatorNode.OperatorType.And, left , right) ;  left = exp ; }
	)*
)
	{return exp ;}
}

ExpressionNode LogicalORExpression(): 
{
	ExpressionNode exp,right,left;
}
{
(
	left = LogicalANDExpression() {exp = left ; } 
	(
		<OR> right = LogicalANDExpression() { exp = new OperatorNode(OperatorNode.OperatorType.Or, left , right) ;  left = exp ; } 
	)*
)
	{return exp ;}
}

//Conditional Expression
ExpressionNode ConditionalExpression():
{
	ExpressionNode exp = null ;
}
{
(	//TODO deal with ? : !!?
	exp = LogicalORExpression() ("?" AssignmentExpression() ":" AssignmentExpression() )?
)
	{return exp ;}
}

ExpressionNode AssignmentExpression(): {
	ExpressionNode exp = null ;
	ExpressionNode left = null,right = null;
	OperatorNode.OperatorType op =null;
}
{

(LOOKAHEAD(LeftHandSideExpression() AssignmentOperator() )
	( left = LeftHandSideExpression() op = AssignmentOperator() right = AssignmentExpression() {exp = new OperatorNode (op,left,right) ;})
	|
	( exp = ConditionalExpression() )
)
	{ 
		return exp;
	}
//(LOOKAHEAD( LeftHandSideExpression() AssignmentOperator() )
	//TODO deal with * how !!!? // a = b = c 
// 	left = LeftHandSideExpression() op = AssignmentOperator() //{ exp2 = new OperatorNode(op,left,null);left = exp2 ; } 
// 	)* 
//	right = ConditionalExpression() 	
}

OperatorNode.OperatorType AssignmentOperator() : 
{
	OperatorNode.OperatorType op ;
	op = OperatorNode.OperatorType.Add ;
}
{
	 ( //TODO Complete it 
	 "*="  { op = OperatorNode.OperatorType.MultiplyBy ; }
	 | "/="  { op = OperatorNode.OperatorType.DivideBy ; }
	 | "%="  { op = OperatorNode.OperatorType.ModBy ; }
	 | "+="  { op = OperatorNode.OperatorType.AddBy ; }
	 | "-="  { op = OperatorNode.OperatorType.SubtractBy ; }
	 | "=" { op = OperatorNode.OperatorType.Assignment ; }
	 )
	 {
	 	return op ;
	 }
}

// Expression Finally !!
void Expression(): {}
{
	AssignmentExpression() ("," AssignmentExpression())*
}


//Statement
void Block() : {}
{
	"{" StatementList() "}"
}

void StatementList() : {}
{
	(Statement())*

}

VariableStatement VariableStatement() : 
{
	HashMap<String, ExpressionNode> values ;
}
{
	<TYPE> values = VariableDeclarationList() ";"
	{ return new VariableStatement(values); }
}

HashMap<String, ExpressionNode> VariableDeclarationList() : 
{
	HashMap<String, ExpressionNode> values = new HashMap<String, ExpressionNode>();
	Pair<String, ExpressionNode> temp ;
}
{
	temp = VariableDeclaration() {
		values.put(temp.getLeft(),temp.getRight());
	}  
	( LOOKAHEAD(1) "," temp = VariableDeclaration(){
		values.put(temp.getLeft(), temp.getRight());
	})*
	
	{
		return values ;
	}	
}

Pair<String, ExpressionNode> VariableDeclaration() : 
{
	Pair<String, ExpressionNode> value ;
	Token s ;
	ExpressionNode exp = null; //NOTE: NULL exp means no init => obj is undefined not null !
}
{
	s = <IDENTIFIER> ( exp = Initialiser())?
	{
		value = new Pair<String, ExpressionNode>(s.image,exp);
		return value;
	}
}


void VariableDeclarationListNoIn() : {}
{
	VariableDeclarationNoIn() ( "," VariableDeclarationNoIn())* 
}

void VariableDeclarationNoIn() : {}
{
	<IDENTIFIER> (InitialiserNoIn())?	
}

ExpressionNode Initialiser() : {
	ExpressionNode exp = null;
}
{
	"=" exp = AssignmentExpression()
	{return exp;}
}

void InitialiserNoIn() : {}
{
	"=" //AssignmentExpressionNoIn()
}


void EmptyStatement() : {}
{
	";"
}

void ExpressionStatement() : {}
{
	// TODO [lookahead != {{, function}] 
	Expression() ";"
}

void IfStatement() : {}
{
	<IF> "(" Expression() ")" Statement() (LOOKAHEAD(1) <ELSE> Statement())?
}

void IterationStatement() : {}
{
	DoWhileStatement()
|	WhileStatement()
|	ForStatement()
}

void DoWhileStatement() : {}
{
	<DO> Statement() <WHILE> "(" Expression() ")" ";"
}
void WhileStatement() : {}
{
	<WHILE> "(" Expression() ")" Statement()
}

void ForStatement() : {}
{
	<FOR> "(" 
	(
//		(ExpressionNoIn())? ";" (Expression())? ";" (Expression())? ")" Statement()
//		<TYPE> VariableDeclarationListNoIn() ";" (Expression())? ";" (Expression())? ")" Statement()
//	|	<TYPE> VariableDeclarationNoIn() "in" Expression() ")" Statement()
//	|
(LOOKAHEAD(LeftHandSideExpression() "in")
		LeftHandSideExpression() "in" Expression() ")" Statement()
	|	(Expression())? ";" (Expression())? ";" (Expression())? ")" Statement()

	)
)
}

void ContinueStatement() : {}
{
	<CONTINUE>
(	(";")
|
//	[no LineTerminator here] 
	(<IDENTIFIER> ";" )
)
}

// FunctionDeclaration
void FunctionDeclaration() : {}
{
	<FUNCTION> <IDENTIFIER> "(" ( FormalParameterList() )? ")" "{" FunctionBody() "}"
}

void FunctionExpression() : {}
{
	<FUNCTION> (<IDENTIFIER>)? "(" (FormalParameterList())? ")" "{" FunctionBody() "}"
}

void FormalParameterList() : {} 
{
	<IDENTIFIER> ("," <IDENTIFIER>)* 
}

void FunctionBody() : {}
{
	(SourceElements())?
}

void ReturnStatement() : {} 
{
	<RETURN> (Expression())? ";" 
	//[no LineTerminator here]	
}

void BreakStatement() : {}
{
	<BREAK> (<IDENTIFIER>)? ";"
	// [no LineTerminator here]
}

void Statement() : {}
{
	Block()
|	VariableStatement()
|	EmptyStatement()
|	ExpressionStatement()
|	IfStatement()
|	IterationStatement()
|	ReturnStatement()
|	BreakStatement()
/*|	ContinueStatement()
|	WithStatment
*/

}

// Program
void Program() : {}
{
	(SourceElements())? // ?
}

void SourceElements() : {}
{
	(SourceElement())+
}

void SourceElement() : {}
{
	//TODO FIXED IT
( LOOKAHEAD (FunctionDeclaration())
	FunctionDeclaration() 
|	Statement()
)
}

void start() : {}
{
	Program() (<EOF>)?
//AssignmentExpression() ";"
	//NumericLiteral()
	
}
